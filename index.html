<!DOCTYPE html>
<html>
<head>
<link href='https://fonts.googleapis.com/css?family=Fira+Sans:400,300,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Work+Sans:400,300,600' rel='stylesheet' type='text/css'>
  <title>Glastress</title>

</head>
<body>

  <!--react root-->
  <div id="gt-app" class="gt-app"></div>

  <!--preload audio files-->  
  <audio id="track" src="assets/audio/glasstress.mp3"></audio> 
  <audio id="sfx01" src="assets/audio/sfx/1.mp3"></audio>
  <audio id="sfx02" src="assets/audio/sfx/2.mp3"></audio>
  <audio id="sfx03" src="assets/audio/sfx/3.mp3"></audio>
  <audio id="sfx04" src="assets/audio/sfx/4.mp3"></audio>
  <audio id="sfx05" src="assets/audio/sfx/5.mp3"></audio>
  <audio id="sfx06" src="assets/audio/sfx/6.mp3"></audio>
  <audio id="sfx07" src="assets/audio/sfx/7.mp3"></audio>
  <audio id="sfx08" src="assets/audio/sfx/8.mp3"></audio>
  <audio id="sfx09" src="assets/audio/sfx/9.mp3"></audio>

  
  <!--<script src="http://localhost:8000/libs/three.js"></script>-->
  
  <!--<script src="http://localhost:5000/js/ShaderPass.js"></script>
  <script src="http://localhost:5000/js/BleachBypassShader.js"></script>
  <script src="http://localhost:5000/js/BlendShader.js"></script>
  <script src="http://localhost:5000/js/FXAAShader.js"></script>
  <script src="http://localhost:5000/js/HorizontalTiltShiftShader.js"></script>
  <script src="http://localhost:5000/js/VerticalTiltShiftShader.js"></script>
  <script src="http://localhost:5000/js/TriangleBlurShader.js"></script>
  <script src="http://localhost:5000/js/VignetteShader.js"></script>
  <script src="http://localhost:5000/js/ConvolutionShader.js"></script>
  <script src="http://localhost:5000/js/DotScreenShader.js"></script>
  <script src="http://localhost:5000/js/RGBShiftShader.js"></script>
  <script src="http://localhost:5000/js/EffectComposer.js"></script>
  <script src="http://localhost:5000/js/RenderPass.js"></script>
  <script src="http://localhost:5000/js/BloomPass.js"></script>
  <script src="http://localhost:5000/js/MaskPass.js"></script>-->
  

  <div id="bpm-helper">

  </div>
  <script id="vertexShader1" type="x-shader/x-vertex">
  uniform vec3 viewVector;
  uniform float c;
  uniform float p;
  varying float intensity;
  void main() 
  {
      vec3 vNormal = normalize( normalMatrix * normal );
    vec3 vNormel = normalize( normalMatrix * viewVector );
    intensity = pow( c - dot(vNormal, vNormel), p );
    
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
  </script>

  <script id="fragmentShader1" type="x-shader/x-fragment"> 
  uniform vec3 glowColor;
  varying float intensity;
  void main() 
  {
    vec3 glow = glowColor * intensity;
      gl_FragColor = vec4( glow, 1.0 );
  }
  </script>

  <!-- landscape mesh -->
  <script type="application/x-glsl" id="sky-vertex">
  varying vec2 vUV;
  varying float vDensity;
  varying float vDiff;
  uniform float fisheye;
  uniform float aspect;
  uniform float space;
  const float fogScale = 12.0;
  const float fogOffset = -0.5;
  void main() {
    vUV = uv;
    // Get world pos
    vec4 pos = vec4(position, 1.0);
    vec3 worldPos = (modelMatrix * pos).xyz;
    vec3 capPos = worldPos;
    capPos.y = max(8.0, capPos.y);
    // Volumetric fog per vertex
    vec3 diff = cameraPosition - capPos;
    float factor = min(10.0, length(diff) / abs(diff.y));
    vec2 depths = (-vec2(capPos.y, cameraPosition.y) + fogOffset) * fogScale;
    vDensity = abs(exp(depths.x) - exp(depths.y)) * factor * .001;
    // Brightness decay at horizon
    float scale = (cameraPosition.y + 1.0) * 60.0;
    vDiff = (worldPos.y + scale) * .0033 * scale / (scale + 1.0);
    // Project
    gl_Position = projectionMatrix * modelViewMatrix * pos;
    if (space > 0.5) {
      vDiff = 1.0;
      vDensity = 0.0;
    }
    // fisheye
    if (gl_Position.z / gl_Position.w > 0.01) {
      vec2 dxy = gl_Position.xy / gl_Position.w * vec2(aspect, 1.0);
      gl_Position.xy /= min(2.3, 1.0 + dot(dxy, dxy) * fisheye * .1);
    }
  }
  </script>

  <!-- sky + volumetric fog at infinity -->
  <script type="application/x-glsl" id="sky-density">
  uniform sampler2D texture;
  varying vec2 vUV;
  varying float vDensity;
  varying float vDiff;
  void main() {
    vec4 sample = texture2D(texture, vUV);
    float diff = clamp(vDiff, 0.0, 1.0);
    float decay = (3.0 - 2.0*diff)*diff*diff;
    gl_FragColor = vec4(sample.xyz * decay + vDensity, sample.w);
  }
  </script>


  <script type="application/x-glsl" id="vertexShader">
//
// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
  { 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
  }
  
  varying vec2 vUv;
  varying vec3 vReflect;
  varying vec3 pos;
  varying float ao;
  uniform float time;
  uniform float weight;
  varying float d;

  float stripes( float x, float f) {
    float PI = 3.14159265358979323846264;
    float t = .5 + .5 * sin( f * 2.0 * PI * x);
    return t * t - .5;
  }
  
  float turbulence( vec3 p ) {
    float w = 100.0;
    float t = -.5;
    for (float f = 1.0 ; f <= 10.0 ; f++ ){
      float power = pow( 2.0, f );
      t += abs( snoise( vec3( power * p ) + time ) / power );
    }
    return t;
  }

  void main() {

    vUv = uv;
  
    vec4 mPosition = objectMatrix * vec4( position, 1.0 );
    vec3 nWorld = normalize( mat3( objectMatrix[0].xyz, objectMatrix[1].xyz, objectMatrix[2].xyz ) * normal );
    vReflect = normalize( reflect( normalize( mPosition.xyz - cameraPosition ), nWorld ) );
    
    pos = position;
    //float noise = .3 * snoise( 8.0 * vec3( normal ) );
    float noise = 10.0 * -.10 * turbulence( .5 * normal );
    //float noise = - stripes( normal.x + 2.0 * turbulence( normal ), 1.6 );

    float displacement = - weight * noise;
    ao = noise;
    vec3 newPosition = position + normal * vec3( displacement );
    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
  
  }

  </script>
  
  <script type="x-shader/x-vertex" id="fragmentShader">

  varying vec2 vUv;
  uniform sampler2D tExplosion;
  varying vec3 vReflect;
  varying vec3 pos;
  varying float ao;
  varying float d;
  float PI = 3.14159265358979323846264;

  void main() {

    vec3 color = texture2D( tExplosion, vec2( 0, .85 - ao ) ).rgb;
    gl_FragColor = vec4( color.rgb, 1.0 );

  }
  
  </script>


  <script src="assets/app.js?124124121"></script>
</body>
</html>